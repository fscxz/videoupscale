<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Upscaler 4K Gr√°tis (Imagem & V√≠deo) ‚Äì 100% no navegador</title>
  <meta name="description" content="Fa√ßa upscale profissional de imagens e v√≠deos para 4K direto no navegador, usando WebGPU/ONNX Runtime Web e FFmpeg.wasm. Hospedagem gr√°tis via GitHub Pages." />
  <style>
    :root { --bg:#0b0f14; --panel:#111827; --muted:#64748b; --text:#e2e8f0; --brand:#7c3aed; --ok:#10b981; --warn:#f59e0b; --err:#ef4444; }
    html,body { margin:0; height:100%; background:linear-gradient(180deg,#0b0f14,#0f172a); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { max-width:1200px; margin:0 auto; padding:24px; }
    header { display:flex; gap:16px; align-items:center; justify-content:space-between; }
    .title { font-size:24px; font-weight:800; letter-spacing:.3px; }
    .badge { font-size:12px; padding:4px 8px; border-radius:999px; background:rgba(124,58,237,.15); border:1px solid rgba(124,58,237,.35); color:#c4b5fd }
    .card { background:rgba(17,24,39,.7); backdrop-filter:saturate(1.2) blur(6px); border:1px solid rgba(148,163,184,.15); border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25); }
    .grid { display:grid; grid-template-columns:1fr; gap:16px; }
    @media(min-width:960px){ .grid { grid-template-columns: 380px 1fr; } }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .btn { cursor:pointer; appearance:none; border:none; border-radius:12px; padding:10px 14px; font-weight:700; color:white; background:linear-gradient(135deg,#7c3aed,#2563eb); box-shadow:0 6px 18px rgba(37, 99, 235, .35); }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .btn.secondary { background:rgba(148,163,184,.15); color:#e2e8f0; box-shadow:none; border:1px solid rgba(148,163,184,.25) }
    .btn.ghost { background:transparent; border:1px dashed rgba(148,163,184,.35); }
    .pill { display:inline-flex; align-items:center; gap:8px; border-radius:999px; border:1px solid rgba(100,116,139,.3); padding:8px 10px; color:#cbd5e1; }
    input[type=file] { display:none }
    label.file { display:inline-flex; align-items:center; gap:10px; background:rgba(148,163,184,.08); border:1px dashed rgba(148,163,184,.35); padding:12px 16px; border-radius:14px; cursor:pointer; font-weight:600; }
    .preview { display:grid; grid-template-columns:1fr; gap:12px; }
    @media(min-width:720px){ .preview { grid-template-columns:1fr 1fr; } }
    .preview canvas, .preview video, .preview img { width:100%; border-radius:12px; border:1px solid rgba(148,163,184,.2); background:#0b0f14 }
    .small { font-size:12px; color:var(--muted); }
    progress { width:100%; height:10px; border-radius:999px; overflow:hidden; background:rgba(148,163,184,.2); }
    progress::-webkit-progress-bar{ background:transparent }
    progress::-webkit-progress-value{ background:linear-gradient(90deg,#7c3aed,#22c55e) }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; color:#cbd5e1; background:#0b1220; border:1px solid rgba(148,163,184,.2); border-radius:10px; padding:10px; max-height:180px; overflow:auto; }
    .chip { padding:4px 8px; border-radius:8px; background:rgba(99,102,241,.12); border:1px solid rgba(99,102,241,.3); font-size:12px }
    .hidden { display:none }
    .foot { opacity:.8; font-size:12px; text-align:center; margin-top:24px }
    a { color:#93c5fd }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="row">
        <div class="title">Upscaler 4K Gr√°tis</div>
        <span class="badge">WebGPU + ONNX + FFmpeg.wasm</span>
      </div>
      <div class="row small">
        <span id="gpuBadge" class="chip">Checando WebGPU‚Ä¶</span>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <h2>Entrada</h2>
        <p class="small">Carregue <strong>imagem</strong> (PNG/JPG) ou <strong>v√≠deo</strong> (MP4/WebM). O processamento acontece 100% no navegador.</p>
        <div class="row">
          <label for="file" class="file">üìÅ Escolher arquivo (imagem/v√≠deo)</label>
          <input id="file" type="file" accept="image/*,video/*" />
          <button class="btn secondary" id="demoBtn">Usar demo</button>
        </div>
        <hr style="border-color: rgba(148,163,184,.2)" />
        <h3>Configura√ß√µes</h3>
        <div class="row">
          <div class="pill">
            Escala:
            <select id="scale">
              <option value="2">2√ó</option>
              <option value="3">3√ó</option>
              <option value="4" selected>4√ó (4K alvo)</option>
            </select>
          </div>
          <div class="pill">
            Modo IA:
            <select id="mode">
              <option value="realesrgan">Real-ESRGAN (IA)</option>
              <option value="waifu2x">Waifu2x (anime)</option>
              <option value="bicubic">Bic√∫bico (r√°pido)</option>
            </select>
          </div>
          <div class="pill">
            Sa√≠da:
            <select id="format">
              <option value="png">PNG (sem perdas)</option>
              <option value="jpg">JPG</option>
              <option value="webp" selected>WebP</option>
              <option value="mp4">MP4 (para v√≠deo)</option>
              <option value="webm">WebM (para v√≠deo)</option>
            </select>
          </div>
        </div>
        <div class="row">
          <button class="btn" id="runBtn">üöÄ Upscale</button>
          <button class="btn ghost" id="dlBtn" disabled>‚¨áÔ∏è Baixar</button>
          <button class="btn secondary" id="resetBtn">Limpar</button>
        </div>
        <div class="small">Modelos .onnx esperados na pasta <code>/models</code> do seu reposit√≥rio: <code>realesrgan-x2plus.onnx</code>, <code>realesrgan-x4plus.onnx</code>, <code>waifu2x-anime.onnx</code>. Voc√™ pode trocar/complementar.</div>
        <br />
        <progress id="prog" value="0" max="100"></progress>
        <div id="status" class="small">Pronto</div>
      </section>

      <section class="card">
        <h2>Pr√©‚Äëvisualiza√ß√£o</h2>
        <div class="preview">
          <div>
            <div class="small">Original</div>
            <img id="imgIn" class="hidden" />
            <video id="vidIn" class="hidden" controls></video>
            <canvas id="canvasIn"></canvas>
          </div>
          <div>
            <div class="small">Upscaled</div>
            <img id="imgOut" class="hidden" />
            <video id="vidOut" class="hidden" controls></video>
            <canvas id="canvasOut"></canvas>
          </div>
        </div>
        <br />
        <div class="log" id="log"></div>
      </section>
    </div>

    <div class="foot">Feito para hospedar no <strong>GitHub Pages</strong>. Nenhum arquivo sai do seu PC. | ¬© Voc√™ ‚Äì Licen√ßa MIT</div>
  </div>

  <!-- Depend√™ncias de runtime no navegador -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js"></script>

  <script>
    // Utilidades de UI
    const $ = sel => document.querySelector(sel);
    const log = (...a)=>{ const el=$('#log'); el.textContent += a.join(' ') + "\n"; el.scrollTop = el.scrollHeight; };
    const setStatus = t=> $('#status').textContent = t;
    const setProgress = v=> $('#prog').value = v;

    // Checagens de suporte
    (function(){
      const hasWebGPU = !!navigator.gpu;
      const hasWasmSIMD = WebAssembly && WebAssembly.validate && WebAssembly.compile;
      const badge = $('#gpuBadge');
      if(hasWebGPU){ badge.textContent = 'WebGPU dispon√≠vel ‚úÖ (mais r√°pido)'; badge.style.borderColor = 'rgba(16,185,129,.5)'; }
      else { badge.textContent = 'Sem WebGPU ‚Äì usa CPU/WASM ‚ö†Ô∏è'; badge.style.borderColor = 'rgba(245,158,11,.5)'; }
    })();

    // Estado global simples
    const state = {
      file: null,
      isVideo: false,
      outputBlob: null,
      model: null,
      session: null,
      scale: 4,
      mode: 'realesrgan'
    };

    // Inputs
    $('#file').addEventListener('change', (e)=> handleFile(e.target.files?.[0]||null));
    $('#demoBtn').addEventListener('click', useDemo);
    $('#scale').addEventListener('change', e=> state.scale = parseInt(e.target.value,10));
    $('#mode').addEventListener('change', e=> state.mode = e.target.value);
    $('#runBtn').addEventListener('click', runUpscale);
    $('#dlBtn').addEventListener('click', ()=>{
      if(!state.outputBlob) return;
      const a = document.createElement('a');
      const ext = state.isVideo ? ($('#format').value||'webm') : ($('#format').value||'png');
      a.href = URL.createObjectURL(state.outputBlob);
      a.download = `upscaled_${Date.now()}.${ext}`;
      a.click();
    });
    $('#resetBtn').addEventListener('click', ()=>{ location.reload(); });

    async function useDemo(){
      // Gera uma imagem demo procedural
      const c = document.createElement('canvas');
      c.width = 320; c.height = 180;
      const ctx = c.getContext('2d');
      const grad = ctx.createLinearGradient(0,0,320,180);
      grad.addColorStop(0,'#1f2937'); grad.addColorStop(.5,'#3b82f6'); grad.addColorStop(1,'#10b981');
      ctx.fillStyle = grad; ctx.fillRect(0,0,320,180);
      ctx.fillStyle = 'white'; ctx.font = 'bold 24px sans-serif';
      ctx.fillText('DEMO 360p', 80, 95);
      const blob = await new Promise(r=> c.toBlob(r,'image/png'));
      handleFile(new File([blob], 'demo.png', {type:'image/png'}));
    }

    async function handleFile(file){
      if(!file) return;
      state.file = file;
      state.isVideo = file.type.startsWith('video');
      $('#canvasIn').getContext('2d').clearRect(0,0,9999,9999);
      $('#canvasOut').getContext('2d').clearRect(0,0,9999,9999);
      $('#imgIn').classList.add('hidden');
      $('#vidIn').classList.add('hidden');
      $('#imgOut').classList.add('hidden');
      $('#vidOut').classList.add('hidden');

      if(state.isVideo){
        const url = URL.createObjectURL(file);
        const v = $('#vidIn'); v.src = url; v.classList.remove('hidden');
        await v.play().catch(()=>{}); v.pause();
        drawToCanvas(v, $('#canvasIn'));
        setStatus(`V√≠deo carregado: ${Math.round(v.videoWidth)}√ó${Math.round(v.videoHeight)} @ ${(v.duration||0).toFixed(2)}s`);
      } else {
        const url = URL.createObjectURL(file);
        const img = $('#imgIn'); img.src = url; await img.decode(); img.classList.remove('hidden');
        drawToCanvas(img, $('#canvasIn'));
        setStatus(`Imagem carregada: ${img.naturalWidth}√ó${img.naturalHeight}`);
      }
    }

    function drawToCanvas(media, canvas){
      const ctx = canvas.getContext('2d');
      const w = media.videoWidth || media.naturalWidth || media.width;
      const h = media.videoHeight || media.naturalHeight || media.height;
      canvas.width = w; canvas.height = h;
      ctx.drawImage(media,0,0,w,h);
    }

    // Carrega sess√£o ONNX (modelos devem estar na pasta /models do reposit√≥rio)
    async function ensureModel(){
      if(state.session) return state.session;
      const provider = navigator.gpu ? 'webgpu' : 'wasm';
      setStatus(`Carregando modelo (${state.mode}) via ${provider}‚Ä¶`);
      log('Provider:', provider);
      const modelMap = {
        'realesrgan-2': 'models/realesrgan-x2plus.onnx',
        'realesrgan-4': 'models/realesrgan-x4plus.onnx',
        'waifu2x': 'models/waifu2x-anime.onnx'
      };
      const key = (state.mode==='waifu2x')? 'waifu2x' : (state.scale>=4? 'realesrgan-4':'realesrgan-2');
      const session = await ort.InferenceSession.create(modelMap[key], { executionProviders: [provider] });
      state.session = session; return session;
    }

    // Converte CanvasImageData -> tensor NCHW float32 [1,3,H,W], RGB 0..1
    function imageDataToTensor(imgData){
      const { data, width, height } = imgData;
      const f32 = new Float32Array(width * height * 3);
      let p=0;
      for(let i=0;i<data.length;i+=4){
        // Normalize 0..1; model usa RGB
        f32[p++] = data[i]   / 255; // R
        f32[p++] = data[i+1] / 255; // G
        f32[p++] = data[i+2] / 255; // B
      }
      // Transp√µe HWC -> CHW
      const chw = new Float32Array(width*height*3);
      let c0=0,c1=width*height,c2=2*width*height;
      p=0;
      for(let y=0;y<height;y++){
        for(let x=0;x<width;x++){
          const r=f32[p++], g=f32[p++], b=f32[p++];
          chw[c0++] = r; chw[c1++] = g; chw[c2++] = b;
        }
      }
      return { tensor: new ort.Tensor('float32', chw, [1,3,height,width]), width, height };
    }

    // Converte tensor CHW -> ImageData
    function tensorToImageData(t){
      const [n, c, h, w] = t.dims; // [1,3,H,W]
      const rOff=0, gOff=w*h, bOff=2*w*h;
      const out = new Uint8ClampedArray(w*h*4);
      let p=0;
      for(let i=0;i<w*h;i++){
        out[p++] = Math.max(0, Math.min(255, Math.round(t.data[rOff+i]*255)));
        out[p++] = Math.max(0, Math.min(255, Math.round(t.data[gOff+i]*255)));
        out[p++] = Math.max(0, Math.min(255, Math.round(t.data[bOff+i]*255)));
        out[p++] = 255;
      }
      return new ImageData(out, w, h);
    }

    async function upscaleImageInTiles(srcCanvas, dstCanvas, tile=256){
      // Divide em blocos para reduzir consumo de mem√≥ria
      await ensureModel();
      const sCtx = srcCanvas.getContext('2d');
      const dCtx = dstCanvas.getContext('2d');
      const sw = srcCanvas.width, sh = srcCanvas.height;
      const scale = state.scale;
      dstCanvas.width = Math.round(sw*scale);
      dstCanvas.height = Math.round(sh*scale);

      for(let y=0; y<sh; y+=tile){
        for(let x=0; x<sw; x+=tile){
          const tw = Math.min(tile, sw-x);
          const th = Math.min(tile, sh-y);
          const patch = sCtx.getImageData(x,y,tw,th);
          const { tensor } = imageDataToTensor(patch);
          const feeds = {};
          // Modelos podem usar input names diferentes; tentamos alguns comuns
          const inputName = state.session.inputNames?.[0] || 'input' || 'inp' || 'data';
          feeds[inputName] = tensor;
          const outputMap = await state.session.run(feeds);
          const outTensor = outputMap[ state.session.outputNames?.[0] ];
          const outImg = tensorToImageData(outTensor);
          dCtx.putImageData(outImg, x*scale, y*scale);
        }
        setProgress(Math.round((y/sh)*100));
        await new Promise(r=> setTimeout(r)); // yield √† UI
      }
      setProgress(100);
    }

    async function runUpscale(){
      if(!state.file){ alert('Selecione um arquivo primeiro.'); return; }
      setStatus('Processando‚Ä¶'); setProgress(0); log('Iniciando...');
      const isVideo = state.isVideo;
      if(!isVideo){
        // IMAGEM
        const inC = $('#canvasIn'); const outC = $('#canvasOut');
        if(state.mode==='bicubic'){
          // Upscale r√°pido via canvas
          const sw=inC.width, sh=inC.height, s=state.scale;
          outC.width = Math.round(sw*s); outC.height = Math.round(sh*s);
          const ctx = outC.getContext('2d');
          ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(inC, 0,0, outC.width, outC.height);
          const blob = await new Promise(r=> outC.toBlob(r, 'image/'+($('#format').value||'webp'), .98));
          state.outputBlob = blob; $('#dlBtn').disabled = false; setStatus('OK ‚Äì Bic√∫bico'); return;
        }
        try{
          await upscaleImageInTiles(inC, outC, 256);
          const blob = await new Promise(r=> outC.toBlob(r, 'image/'+($('#format').value||'webp'), .98));
          state.outputBlob = blob; $('#dlBtn').disabled = false;
          $('#imgOut').src = URL.createObjectURL(blob); $('#imgOut').classList.remove('hidden');
          setStatus('Conclu√≠do ‚úÖ');
        } catch(err){
          console.error(err); log('Falha IA, caindo para bic√∫bico. Detalhe:', err.message||err);
          // Fallback simples
          const sw=inC.width, sh=inC.height, s=state.scale;
          outC.width = Math.round(sw*s); outC.height = Math.round(sh*s);
          const ctx = outC.getContext('2d');
          ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(inC, 0,0, outC.width, outC.height);
          const blob = await new Promise(r=> outC.toBlob(r, 'image/webp', .98));
          state.outputBlob = blob; $('#dlBtn').disabled = false; setStatus('Conclu√≠do (fallback)');
        }
      } else {
        // V√çDEO ‚Äì pipeline simplificado frame‚Äëa‚Äëframe
        const v = $('#vidIn');
        const fps = Math.min(30, Math.max(8, Math.floor(v.getVideoPlaybackQuality?.().totalVideoFrames ? v.getVideoPlaybackQuality().totalVideoFrames / v.duration : 24)));
        const scale = state.scale; const outC = $('#canvasOut'); const inC = $('#canvasIn');
        outC.width = Math.round(inC.width * scale); outC.height = Math.round(inC.height * scale);

        const { createFFmpeg } = FFmpeg;
        const ffmpeg = createFFmpeg({ log: true });
        await ffmpeg.load();

        // Extrai frames com o pr√≥prio browser
        const frames = await extractFramesBrowser(v, fps);
        log('Frames extra√≠dos:', frames.length);

        let i=0;
        for(const frame of frames){
          // Desenha frame de entrada
          const ctxIn = inC.getContext('2d');
          ctxIn.drawImage(frame,0,0,inC.width,inC.height);
          if(state.mode==='bicubic'){
            const ctxOut = outC.getContext('2d');
            ctxOut.imageSmoothingEnabled=true; ctxOut.imageSmoothingQuality='high';
            ctxOut.drawImage(inC,0,0,outC.width,outC.height);
          } else {
            // IA por tile (pode ser lenta para v√≠deos longos)
            await upscaleImageInTiles(inC, outC, 256);
          }
          const png = await new Promise(r=> outC.toBlob(r,'image/png'));
          const u8 = new Uint8Array(await png.arrayBuffer());
          const name = `f_${String(i).padStart(6,'0')}.png`;
          ffmpeg.FS('writeFile', name, u8);
          i++;
          setProgress(Math.round((i/frames.length)*100));
        }

        // Monta v√≠deo com ffmpeg.wasm
        const outName = ($('#format').value==='mp4')? 'out.mp4' : 'out.webm';
        const codecArgs = ($('#format').value==='mp4')
          ? ['-r', String(fps), '-i', 'f_%06d.png', '-c:v', 'libx264', '-preset', 'veryfast', '-pix_fmt', 'yuv420p', outName]
          : ['-r', String(fps), '-i', 'f_%06d.png', '-c:v', 'libvpx-vp9', '-b:v', '0', '-crf', '28', outName];
        await ffmpeg.run(...codecArgs);
        const data = ffmpeg.FS('readFile', outName);
        state.outputBlob = new Blob([data.buffer], { type: ($('#format').value==='mp4')? 'video/mp4' : 'video/webm' });
        $('#dlBtn').disabled = false;
        $('#vidOut').src = URL.createObjectURL(state.outputBlob); $('#vidOut').classList.remove('hidden');
        setStatus('V√≠deo pronto ‚úÖ');
      }
    }

    async function extractFramesBrowser(video, fps){
      // Usa seek + canvas para amostrar frames
      const frames = [];
      const c = document.createElement('canvas'); c.width = video.videoWidth; c.height = video.videoHeight;
      const ctx = c.getContext('2d');
      const total = Math.floor(video.duration * fps);
      for(let i=0;i<total;i++){
        const t = i / fps; video.currentTime = t;
        await new Promise(r=> video.onseeked = ()=> r());
        ctx.drawImage(video,0,0,c.width,c.height);
        const bmp = await createImageBitmap(c);
        frames.push(bmp);
      }
      return frames;
    }
  </script>
</body>
</html>
